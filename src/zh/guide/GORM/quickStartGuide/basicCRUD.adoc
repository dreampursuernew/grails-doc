尝试执行一些基本的CRUD（创建/读取/更新/删除）操作。\r\n\r\n\r\n=== 创建\r\n\r\n\r\n要创建一个领域类，请使用Map构造函数设置其属性并调用<<ref-domain-classes-save,save>>：\r\n\r\n[source,groovy]\r\n----\r\ndef p = new Person(name: \"Fred\", age: 40, lastVisit: new Date())\r\np.save()\r\n----\r\n\r\n<<ref-domain-classes-save,save>>方法将使用底层的Hibernate ORM层将您的类持久化到数据库中。\r\n\r\n\r\n=== 读取\r\n\r\n\r\nGrails透明地为您的领域类添加了一个隐式的 `id` 属性，您可以用于检索：\r\n\r\n[source,groovy]\r\n----\r\ndef p = Person.get(1)\r\nassert 1 == p.id\r\n----\r\n\r\n这使用期望数据库标识符的<<ref-domain-classes-get,get>>方法从数据库中返回 `Person` 对象。\r\n您还可以通过使用<<ref-domain-classes-read,read>>方法以只读状态加载对象：\r\n\r\n[source,groovy]\r\n----\r\ndef p = Person.read(1)\r\n----\r\n\r\n在这种情况下，底层的Hibernate引擎将不会进行任何脏检查，并且该对象将不会持久化。请注意，如果您显式调用<<ref-domain-classes-save,save>>方法，则对象将重新进入读写状态。\r\n\r\n此外，您还可以通过使用<<ref-domain-classes-load,load>>方法加载实例的代理：\r\n\r\n[source,groovy]\r\n----\r\ndef p = Person.load(1)\r\n----\r\n\r\n直到调用非getId（）方法之前，这不会发生任何数据库访问。然后，Hibernate初始化被代理的实例，或者如果找不到指定id的记录则抛出异常。\r\n\r\n\r\n=== 更新\r\n\r\n\r\n要更新一个实例，请更改一些属性，然后再次调用<<ref-domain-classes-save,save>>：\r\n\r\n[source,groovy]\r\n----\r\ndef p = Person.get(1)\r\np.name = \"Bob\"\r\np.save()\r\n----\r\n\r\n\r\n=== 删除\r\n\r\n\r\n要删除一个实例，请使用<<ref-domain-classes-delete,delete>>方法：\r\n\r\n[source,groovy]\r\n----\r\ndef p = Person.get(1)\r\np.delete()\r\n----\r\n\r\n\r\n\r\n\r\n"