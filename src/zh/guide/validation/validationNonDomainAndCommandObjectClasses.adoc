链接:GORM.html[域类]和链接:theWebLayer.html#commandObjects[命令对象]默认支持验证。 其他类可以通过在类中定义静态 `constraints` 属性（如上所述）并告诉框架有关它们来进行验证。 应用程序注册可验证类与框架之间的关系很重要。 仅定义 `constraints` 属性是不够的。\r\n\r\n==== 可验证 Trait\r\n\r\n定义静态 `constraints` 属性并实现{apiDocs}grails/validation/Validateable.html[可验证] trait的类将是可验证的。 请考虑以下示例:\r\n\r\n[source,groovy]\r\n.src/main/groovy/com/mycompany/myapp/User.groovy\r\n----\r\npackage com.mycompany/myapp\r\n\r\nimport grails.validation.Validateable\r\n\r\nclass User implements Validateable {\r\n    ...\r\n\r\n    static constraints = {\r\n        login size: 5..15, blank: false, unique: true\r\n        password size: 5..15, blank: false\r\n        email email: true, blank: false\r\n        age min: 18\r\n    }\r\n}\r\n----\r\n\r\n===== 编程访问\r\n\r\n访问可验证对象的约束略有不同。 您可以通过访问类的 `constraintsMap` 静态属性在另一个上下文中以编程方式访问命令对象的约束。 该属性是 `Map<String, {apiDocs}grails/validation/ConstrainedProperty.html[ConstrainedProperty]>` 的实例。\r\n\r\n在上面的示例中，访问 `User.constraintsMap.login.blank` 会产生 `false` ，而访问 `User.constraintsMap.login.unique` 将会产生 `true` 。