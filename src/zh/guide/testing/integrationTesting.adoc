集成测试与单元测试不同之处在于，您在测试中完全可以访问Grails环境。您可以使用链接：../ref/Command%20Line/create-integration-test.html[create-integration-test] 命令创建一个集成测试：\r\n\r\n[source,groovy]\r\n----\r\n$ grails create-integration-test Example\r\n----\r\n\r\n上述命令将在位置 `src/integration-test/groovy/<PACKAGE>/ExampleSpec.groovy` 创建一个新的集成测试。\r\n\r\nGrails在集成测试中使用测试环境，并在第一次运行测试之前加载应用程序。所有测试都使用相同的应用程序状态。\r\n\r\n==== 事务\r\n\r\n默认情况下，集成测试方法在其自己的数据库事务中运行，并在每个测试方法结束时回滚。这意味着在测试期间保存的数据不会持久保存到数据库（这些是所有测试共享的）。默认生成的集成测试模板包括{apiDocs}grails/transaction/Rollback.html[Rollback] 注解：\r\n\r\n[source,groovy]\r\n----\r\nimport grails.testing.mixin.integration.Integration\r\nimport grails.gorm.transactions.*\r\nimport spock.lang.*\r\n\r\n@Integration\r\n@Rollback\r\nclass ExampleSpec extends Specification {\r\n\r\n    ...\r\n\r\n    void \"test something\"() {\r\n        expect:\"fix me\"\r\n            true == false\r\n    }\r\n}\r\n----\r\n\r\n `Rollback` 注解确保每个测试方法在回滚的事务中运行。通常这是可取的，因为您不希望测试依赖于顺序或应用程序状态。\r\n\r\n在Grails 3.0中，测试依赖于 `grails.gorm.transactions.Rollback` 注解来将会话绑定到集成测试中。虽然每个测试方法的事务会被回滚，但 `setup()` 方法使用的是一个不会被回滚的单独事务。\r\n如果 `setup()` 设置数据并将其持久化，数据将持久保存到数据库，并且需要手动清理。\r\n\r\n要预先加载数据库并自动回滚设置逻辑，任何持久化操作都需要在测试方法本身中调用，以便它们可以在测试方法的回滚事务中运行。类似于以下示例中显示的 `setupData()` 方法的使用，它可以在数据库中创建一条记录，在运行其他测试后将被回滚：\r\n\r\n[source,groovy]\r\n----\r\nimport grails.testing.mixin.integration.Integration\r\nimport grails.gorm.transactions.*\r\nimport spock.lang.*\r\n\r\n@Integration\r\n@Rollback\r\nclass BookSpec extends Specification {\r\n\r\n    void setupData() {\r\n        // 下面的代码将会被回滚\r\n        new Book(name: 'Grails in Action').save(flush: true)\r\n    }\r\n\r\n    void \"test something\"() {\r\n        given:\r\n        setupData()\r\n\r\n        expect:\r\n        Book.count() == 1\r\n    }\r\n}\r\n----\r\n\r\n==== 使用Spring的Rollback注解\r\n\r\n另一种事务处理方法是使用Spring的{springapi}org/springframework/test/annotation/Rollback.html[@Rollback] 注解。\r\n\r\n[source,groovy]\r\n----\r\nimport grails.testing.mixin.integration.Integration\r\nimport org.springframework.test.annotation.Rollback\r\nimport spock.lang.*\r\n\r\n@Integration\r\n@Rollback\r\nclass BookSpec extends Specification {\r\n\r\n    void setup() {\r\n        new Book(name: 'Grails in Action').save(flush: true)\r\n    }\r\n\r\n    void \"test something\"() {\r\n        expect:\r\n        Book.count() == 1\r\n    }\r\n}\r\n----\r\n\r\n请注意： `grails.gorm.transactions.Rollback` 无法像Spring的Rollback注解一样工作，因为 `grails.gorm.transactions.Rollback` 转换类的字节码，消除了代理的需要（而Spring的版本需要代理）。\r\n这样做的缺点是您无法根据不同情况（测试的情况）实现不同的行为。\r\n\r\n==== DirtiesContext\r\n\r\n如果您有一系列共享状态的测试，您可以删除 `Rollback` ，并且套件中的最后一个测试应该有{springapi}org/springframework/test/annotation/DirtiesContext.html[DirtiesContext] 注解，它将关闭环境并重新启动（请注意，这会影响测试运行时间）。 \r\n\r\n==== 自动装配\r\n\r\n要获取对bean的引用，您可以使用{springapi}org/springframework/beans/factory/annotation/Autowired.html[Autowired] 注解。例如：\r\n\r\n[source,groovy]\r\n----\r\n...\r\nimport org.springframework.beans.factory.annotation.*\r\n\r\n@Integration\r\n@Rollback\r\nclass ExampleServiceSpec extends Specification {\r\n\r\n    @Autowired\r\n    ExampleService exampleService\r\n    ...\r\n\r\n    void \"Test example service\"() {\r\n        expect:\r\n            exampleService.countExamples() == 0\r\n    }\r\n}\r\n----\r\n\r\n\r\n==== 测试控制器\r\n\r\n建议集成测试控制器时使用链接：../ref/Command%20Line/create-functional-test.html[create-functional-test] 命令创建一个Geb功能测试。有关更多信息，请参见有关功能测试的以下部分。\r\n"